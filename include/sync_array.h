#include "sort.h"

#define MAKE_ARRAY(T, K);;\
>>> THIS FILE WAS AUTOGENERATED.;;\
>>> DO NOT EDIT.;;\
;;\
import (;;\
	"sync";;\
	"sync/atomic";;\
);;\
;;\
;;\
type STRUCT(Array) struct {;;\
	mu sync.RWMutex;;\
	data SLICE(T);;\
	readers int64;;\
};;\
;;\
func (a *STRUCT(Array)) Has(x K) bool {;;\
	READ_DATA(data);;\
	DO_SEARCH(data, x, i, ok);;\
	return ok;;\
};;\
;;\
func (a *STRUCT(Array)) Get(x K) T {;;\
	READ_DATA(data);;\
	DO_SEARCH(data, x, i, ok);;\
	if !ok {;;\
		return EMPTY();;\
	};;\
	return data[i];;\
};;\
;;\
func (a *STRUCT(Array)) Getsert(x T) (ret T) {;;\
	a.mu.Lock();;\
	DO_SEARCH(a.data, ID(x), i, has);;\
	r := atomic.LoadInt64(&a.readers);;\
	switch {;;\
	case has:;;\
		ret = a.data[i];;\
	case r == 0: >>> no readers, insert inplace;;\
		if cap(a.data) == len(a.data) { >>> not enough storage in array;;\
			goto copyCase;;\
		};;\
		INSERT_INPLACE(a.data, i, x);;\
		ret = x;;\
	copyCase:;;\
		fallthrough;;\
	case r > 0: >>> readers exists, do copy;;\
		INSERT_COPY(a.data, SLICE(T), i, x);;\
		ret = x;;\
	};;\
	a.mu.Unlock();;\
	return;;\
};;\
func (a *STRUCT(Array)) Upsert(x T) (prev T) {;;\
	a.mu.Lock();;\
	DO_SEARCH(a.data, ID(x), i, has);;\
	r := atomic.LoadInt64(&a.readers);;\
	switch {;;\
	case r > 0 && has: >>> readers exists, do copy;;\
		with := make(SLICE(T), len(a.data));;\
		copy(with, a.data);;\
		a.data = with;;\
		fallthrough;;\
	case r == 0 && has: >>> no readers: update in place;;\
		a.data[i], prev = x, a.data[i];;\
	case r == 0 && !has: >>> no readers, insert inplace;;\
		if cap(a.data) == len(a.data) { >>> not enough storage in array;;\
			goto copyCase;;\
		};;\
		INSERT_INPLACE(a.data, i, x);;\
	copyCase:;;\
		fallthrough;;\
	case r > 0 && !has: >>> readers exists, do copy;;\
		INSERT_COPY(a.data, SLICE(T), i, x);;\
	};;\
	a.mu.Unlock();;\
	return;;\
};;\
;;\
func (a *STRUCT(Array)) Delete(x K) (prev T) {;;\
	a.mu.Lock();;\
	DO_SEARCH(a.data, x, i, has);;\
	if !has {;;\
		a.mu.Unlock();;\
		return;;\
	};;\
	prev = a.data[i];;\
	r := atomic.LoadInt64(&a.readers);;\
	switch {;;\
	case r == 0: >>> no readers, delete inplace;;\
		a.data[i] = EMPTY();;\
		a.data = a.data[:i+copy(a.data[i:], a.data[i+1:])];;\
	case r > 0: >>> has readers, copy;;\
		without := make(SLICE(T), len(a.data)-1);;\
		copy(without[:i], a.data[:i]);;\
		copy(without[i:], a.data[i+1:]);;\
		a.data = without;;\
	};;\
	a.mu.Unlock();;\
	return;;\
};;\
;;\
func (a *STRUCT(Array)) Ascend(cb func(x T) bool) bool {;;\
	READ_DATA(data);;\
	for _, x := range data {;;\
		if !cb(x) {;;\
			return false;;\
		};;\
	};;\
	return true;;\
};;\
;;\
func (a *STRUCT(Array)) AscendRange(x, y K, cb func(x T) bool) bool {;;\
	READ_DATA(data);;\
	DO_SEARCH_RANGE(a.data, x, 0, len(a.data), i, hasX);;\
	DO_SEARCH_RANGE(a.data, y, i, len(a.data), j, hasY);;\
	for ; i < len(data) && i <= j; i++ {;;\
		if !cb(data[i]) {;;\
			return false;;\
		};;\
	};;\
	return true;;\
};;\
;;\
func (a *STRUCT(Array)) Len() int {;;\
	a.mu.RLock();;\
	n := len(a.data);;\
	a.mu.RUnlock();;\
	return n;;\
};;\

#define INSERT_INPLACE(DATA, I, X)\
	DATA = DATA[:len(DATA)+1];;\
	copy(DATA[I+1:], DATA[I:]);;\
	DATA[I] = X\

#define INSERT_COPY(DATA, CONTAINER, I, X)\
	with := make(CONTAINER, len(DATA)+1);;\
	copy(with[:I], DATA[:I]);;\
	copy(with[I+1:], DATA[I:]);;\
	with[I] = X;;\
	DATA = with\

#define READ_DATA(DATA)\
	a.mu.RLock();;\
	DATA := a.data;;\
	atomic.AddInt64(&a.readers, 1);;\
	defer atomic.AddInt64(&a.readers, -1);;\
	a.mu.RUnlock()\

