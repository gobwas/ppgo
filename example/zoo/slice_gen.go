// THIS FILE WAS AUTOGENERATED.
// DO NOT EDIT!

package zoo

type Animals struct {
	Data []Animal
}

// NewAnimals creates Animals with underlying data.
// Note that data is not copied and used by reference.
func NewAnimals(data []Animal) Animals {
	_AnimalsSortSource(data, 0, len(data))
	return Animals{Data: data}
}

// _AnimalsSortSource sorts data for further use inside Animals.
func _AnimalsSortSource(data []Animal, lo, hi int) {
	if hi-lo <= 12 {
		// Do insertion sort.
		for i := lo + 1; i < hi; i++ {
			for j := i; j > lo && !(data[j-1].Name <= data[j].Name); j-- {
				data[j], data[j-1] = data[j-1], data[j]
			}
		}
		return
	}
	// Do quick sort.
	var (
		p = lo
		x = data[lo]
	)
	for i := lo + 1; i < hi; i++ {
		if data[i].Name <= x.Name {
			p++
			data[p], data[i] = data[i], data[p]
		}
	}
	data[p], data[lo] = data[lo], data[p]

	if lo < p {
		_AnimalsSortSource(data, lo, p)
	}
	if p+1 < hi {
		_AnimalsSortSource(data, p+1, hi)
	}
}

func (a Animals) Has(x string) bool {
	// Binary search algorithm.
	var ok bool
	var i int
	{
		l := 0
		r := len(a.Data)
		for !ok && l < r {
			m := l + (r-l)/2
			switch {
			case a.Data[m].Name == x:
				ok = true
				r = m
			case a.Data[m].Name < x:
				l = m + 1
			case a.Data[m].Name > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	return ok
}

func (a Animals) Get(x string) (Animal, bool) {
	// Binary search algorithm.
	var ok bool
	var i int
	{
		l := 0
		r := len(a.Data)
		for !ok && l < r {
			m := l + (r-l)/2
			switch {
			case a.Data[m].Name == x:
				ok = true
				r = m
			case a.Data[m].Name < x:
				l = m + 1
			case a.Data[m].Name > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if !ok {
		return Animal{}, false
	}
	return a.Data[i], true
}

// Upsert inserts item x into array or updates existing one.
// It returns copy of Animals, previous item (if were present) and a boolean
// flag that reports about previous item replacement. This flag is useful for
// non-pointer item types such as numbers or struct values.
func (a Animals) Upsert(x Animal) (cp Animals, prev Animal, swapped bool) {
	var with []Animal
	// Binary search algorithm.
	var has bool
	var i int
	{
		l := 0
		r := len(a.Data)
		for !has && l < r {
			m := l + (r-l)/2
			switch {
			case a.Data[m].Name == x.Name:
				has = true
				r = m
			case a.Data[m].Name < x.Name:
				l = m + 1
			case a.Data[m].Name > x.Name:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if has {
		with = make([]Animal, len(a.Data))
		copy(with, a.Data)
		with[i], prev = x, a.Data[i]
		swapped = true
	} else {
		with = make([]Animal, len(a.Data)+1)
		copy(with[:i], a.Data[:i])
		copy(with[i+1:], a.Data[i:])
		with[i] = x
		prev = Animal{}
	}
	return Animals{with}, prev, swapped
}

func (a Animals) Delete(x string) (Animals, Animal, bool) {
	// Binary search algorithm.
	var has bool
	var i int
	{
		l := 0
		r := len(a.Data)
		for !has && l < r {
			m := l + (r-l)/2
			switch {
			case a.Data[m].Name == x:
				has = true
				r = m
			case a.Data[m].Name < x:
				l = m + 1
			case a.Data[m].Name > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if !has {
		return a, Animal{}, false
	}
	without := make([]Animal, len(a.Data)-1)
	copy(without[:i], a.Data[:i])
	copy(without[i:], a.Data[i+1:])
	return Animals{without}, a.Data[i], true
}

func (a Animals) Ascend(cb func(x Animal) bool) bool {
	for _, x := range a.Data {
		if !cb(x) {
			return false
		}
	}
	return true
}

func (a Animals) AscendRange(x, y string, cb func(x Animal) bool) bool {
	// Binary search algorithm.
	var hasX bool
	var i int
	{
		l := 0
		r := len(a.Data)
		for !hasX && l < r {
			m := l + (r-l)/2
			switch {
			case a.Data[m].Name == x:
				hasX = true
				r = m
			case a.Data[m].Name < x:
				l = m + 1
			case a.Data[m].Name > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	// Binary search algorithm.
	var hasY bool
	var j int
	{
		l := i
		r := len(a.Data)
		for !hasY && l < r {
			m := l + (r-l)/2
			switch {
			case a.Data[m].Name == y:
				hasY = true
				r = m
			case a.Data[m].Name < y:
				l = m + 1
			case a.Data[m].Name > y:
				r = m
			}
		}
		j = r
		_ = j // in case when j not being used
	}
	for ; i < len(a.Data) && i <= j; i++ {
		if !cb(a.Data[i]) {
			return false
		}
	}
	return true
}

func (a Animals) Reset() Animals {
	return Animals{nil}
}

func (a Animals) AppendTo(p []Animal) []Animal {
	return append(p, a.Data...)
}
