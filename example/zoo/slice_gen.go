// THIS FILE WAS AUTOGENERATED.
// DO NOT EDIT!

package zoo

type SortedSlice struct {
	data []Animal
}

// NewSortedSlice creates SortedSlice with underlying data.
// Note that data is not copied and used by reference.
func NewSortedSlice(data []Animal) SortedSlice {
	_SortedSliceSortSource(data, 0, len(data))
	return SortedSlice{data: data}
}

// _SortedSliceSortSource sorts data for further use inside SortedSlice.
func _SortedSliceSortSource(data []Animal, lo, hi int) {
	if hi-lo <= 12 {
		// Do insertion sort.
		for i := lo + 1; i < hi; i++ {
			for j := i; j > lo && !(data[j-1].Name <= data[j].Name); j-- {
				data[j], data[j-1] = data[j-1], data[j]
			}
		}
		return
	}
	// Do quick sort.
	var (
		p = lo
		x = data[lo]
	)
	for i := lo + 1; i < hi; i++ {
		if data[i].Name <= x.Name {
			p++
			data[p], data[i] = data[i], data[p]
		}
	}
	data[p], data[lo] = data[lo], data[p]

	if lo < p {
		_SortedSliceSortSource(data, lo, p)
	}
	if p+1 < hi {
		_SortedSliceSortSource(data, p+1, hi)
	}
}

func (a SortedSlice) Has(x string) bool {
	// Binary search algorithm.
	var ok bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !ok && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].Name == x:
				ok = true
				r = m
			case a.data[m].Name < x:
				l = m + 1
			case a.data[m].Name > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	return ok
}

func (a SortedSlice) Get(x string) (Animal, bool) {
	// Binary search algorithm.
	var ok bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !ok && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].Name == x:
				ok = true
				r = m
			case a.data[m].Name < x:
				l = m + 1
			case a.data[m].Name > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if !ok {
		return Animal{}, false
	}
	return a.data[i], true
}

// Upsert inserts item x into array or updates existing one.
// It returns copy of SortedSlice, previous item (if were present) and a boolean
// flag that reports about previous item replacement. This flag is useful for
// non-pointer item types such as numbers or struct values.
func (a SortedSlice) Upsert(x Animal) (cp SortedSlice, prev Animal, swapped bool) {
	var with []Animal
	// Binary search algorithm.
	var has bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !has && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].Name == x.Name:
				has = true
				r = m
			case a.data[m].Name < x.Name:
				l = m + 1
			case a.data[m].Name > x.Name:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if has {
		with = make([]Animal, len(a.data))
		copy(with, a.data)
		with[i], prev = x, a.data[i]
		swapped = true
	} else {
		with = make([]Animal, len(a.data)+1)
		copy(with[:i], a.data[:i])
		copy(with[i+1:], a.data[i:])
		with[i] = x
		prev = Animal{}
	}
	return SortedSlice{with}, prev, swapped
}

func (a SortedSlice) Delete(x string) (SortedSlice, Animal, bool) {
	// Binary search algorithm.
	var has bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !has && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].Name == x:
				has = true
				r = m
			case a.data[m].Name < x:
				l = m + 1
			case a.data[m].Name > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if !has {
		return a, Animal{}, false
	}
	without := make([]Animal, len(a.data)-1)
	copy(without[:i], a.data[:i])
	copy(without[i:], a.data[i+1:])
	return SortedSlice{without}, a.data[i], true
}

func (a SortedSlice) Ascend(cb func(x Animal) bool) bool {
	for _, x := range a.data {
		if !cb(x) {
			return false
		}
	}
	return true
}

func (a SortedSlice) AscendRange(x, y string, cb func(x Animal) bool) bool {
	// Binary search algorithm.
	var hasX bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !hasX && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].Name == x:
				hasX = true
				r = m
			case a.data[m].Name < x:
				l = m + 1
			case a.data[m].Name > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	// Binary search algorithm.
	var hasY bool
	var j int
	{
		l := i
		r := len(a.data)
		for !hasY && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].Name == y:
				hasY = true
				r = m
			case a.data[m].Name < y:
				l = m + 1
			case a.data[m].Name > y:
				r = m
			}
		}
		j = r
		_ = j // in case when j not being used
	}
	for ; i < len(a.data) && i <= j; i++ {
		if !cb(a.data[i]) {
			return false
		}
	}
	return true
}

func (a SortedSlice) Reset() SortedSlice {
	return SortedSlice{nil}
}

func (a SortedSlice) AppendTo(p []Animal) []Animal {
	return append(p, a.data...)
}

func (a SortedSlice) Len() int {
	return len(a.data)
}

func (a SortedSlice) Cap() int {
	return cap(a.data)
}
